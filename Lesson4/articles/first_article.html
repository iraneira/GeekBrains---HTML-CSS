<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<!--[if lt IE 9]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<title></title>
	<meta name="keywords" content="" />
	<meta name="description" content="" />
	<link href="../style.css" rel="stylesheet">
</head>

<body>
	<div class="wrapper">
		<header class="clearfix">
			<nav class="main_nav">
				<ul>
					<li><a href="../index.html">Главная</a></li>
					<li><a class="is_active" href="../articles.html">Статьи</a></li>
					<li><a href="../catalog.html">Каталог</a></li>
					<li><a href="../galery.html">Галерея изображений</a></li>
					<li><a href="../registration.html">Регистрация</a></li>
					<li><a href="../contacts.html">Контакты</a></li>
				</ul>
			</nav>
		</header>
		<div class="article_content clearfix">
			<div class="article_header"><h1>WebRTC chat with React.js</h1></div>

			<p>In this blog post I'm going to share how could be build WebRTC chat with React.js. Before we continue lets describe briefly what React.js and WebRTC are.<br>

			The application from this tutorial is available at GitHub.</p>

			<h3>React.js</h3>

			<p>React.js is reactive JavaScript framework, which helps you to build user interface. Facebook states that we can think of React as the "V" in MVC. React's main aspect is the state. When the state of the application changes this automatically propagates through the application's components. A React component is a self-contained module, which is composed by one or more other components. Usually the component depends on state, which is being provided by a parent component. May be the explanation seems quite abstract now, but during the tutorial the picture will get much more clear.</p>

			<h3>WebRTC</h3>

			<p>RTC stands for Real-Time Communication. Until browsers implemented WebRTC our only way to provide communication between several browsers was to proxy the messages via a server between them (using WebSockets or HTTP). WebRTC makes the peer-to-peer communication between browsers possible. Using the NAT traversal framework - ICE, we are able find the most appropriate route between the browsers and make them communicate without mediator. Since 1st of July 2014, v1.0 of the WebRTC browser APIs standard is already published by W3C.</p>

			<h3>NAT</h3>

			<p>Before we continue with the tutorial, lets say a few words about what NAT is. NAT stands for Network Address Translation. It is quite common way for translating internal (private) IP addresses to public ones and vice verse. A lot of ISP providers with limited capacity of public IP addresses uses this way of scaling using private IP addresses in their internal networks and translating them to public addresses visible to the outside world. More about NAT and the different types of NAT could be read in this wiki article.</p>

			<h3>Implementation</h3>

			<p>Now lets get starting with the actual implementation of our WebRTC based chat.</p>

			<h3>High-level overview</h3>

			<p>Since I'm kind of traditionalist I'll start by providing a basic, high-level overview of the architecture of our p2p (peer to peer) chat.<br>

			The dashed arrows, in the diagram, indicate signaling WebSocket connections. Each client initiates such connection with the server. With these connections each client aims to register itself on the server and use the server as a proxy during the NAT traversal procedures, defined by the signaling protocol (for now we can think of the signaling protocol as SIP or XMPP Jingle). Actually the signaling protocol in our case is provided by Peer.js.<br>

			The solid arrow stands for peer-to-peer TCP or UDP (TCP in our case) data channel between the browsers. We use full mesh, which scales badly especially when we use video or audio streaming. For the purpose of our chat full mesh is good enough.</p>

			<h3>Low-level overview</h3>

			<p>In the beginning of the blog post I mentioned that React.js application contains a finite amount of React.js components composed together. In this subsection I'll illustrate, which are the different components of our application and how they are composed together. The diagram below isn't following the UML standard, it only illustrate, as clearly as possible, our micro-architecture.</p>

			<h3>Micro-architecture</h3>

			<p>Lets concentrate on the left-hand side of the diagram. As you see we have a set of nested components. The most outer, non-named, component (the rectangle, which contains all other rectangles), is the ChatBox component. In its left-hand side is positioned the MessagesList component, which is composition of ChatMessage components. Each ChatMessage component contains a different chat message, which has author, date when published and content. On the right-hand side of the ChatBox is positioned the UsersList component. This component lists all users, which are currently in the chat session. The last component is the MessageInput component. The MessageInput component is a simple text input, which once detect a press of the Enter key triggers an event, with data - its value.<br>

			The ChatBox component uses ChatProxy. The ChatProxy is responsible for registering the current client on the server and talking with the other peers. For simplicity I've used Peer.js, which provides nice high-level API, wrapping the browser's WebRTC API.</p>
			
		</div>
		<h3 id="comments">Комментарии:</h3>
		<div class="comment">
			<p>Здесь оооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооочень длинный комментарий</p>
		</div>
		<div class="comment">
			<p>Еще один длинный комментарий о том как здесь всё криво и вообще, лучше бы это статьи вообще не было! В общем масса негативных отзывов и т.д. и т.п. А у нас в квартире газ, это раз! А у нас водопровод, вот! А из нашего окна площадь красная видна. А из нашего окошка только улицу немножко. Спать пора! Уснул бчок, лег в кроватку на бочок. Сонный мишка лег в кровать, только слон не хочет спать. Головой кивает слон, он слонихе шлет поклон</p>
		</div>
	</div>
	<footer class="clearfix">
		<p>&copy; Все права защищены!</p>
		<nav class="footer_nav">
			<ul>
				<li><a class="is_active" href="../index.html">Главная</a></li>
				<li><a href="../articles.html">Статьи</a></li>
				<li><a href="../catalog.html">Каталог</a></li>
				<li><a href="../galery.html">Галерея изображений</a></li>
				<li><a href="../registration.html">Регистрация</a></li>
				<li><a href="../contacts.html">Контакты</a></li>
			</ul>
		</nav>
	</footer>

</body>
</html>